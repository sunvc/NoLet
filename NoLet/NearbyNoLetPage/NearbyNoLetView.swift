//
//  NearbyNoLetView.swift
//  NoLet
//
//  Created by AI Assistant on 2023/7/1.
//
// Note: This file contains code automatically generated by AI.
// Usage reminder: Review carefully and thoroughly test before integration or release.

import SwiftUI
import MultipeerConnectivity
import PhotosUI
import Photos
import UniformTypeIdentifiers

struct NearbyNoLetView: View {
    @StateObject private var viewModel = NearbyNoLetViewModel()
    @Environment(\.dismiss) var dismiss
    @State private var message = ""
    @State private var showingDevices = false
    @State private var selectedPhotoItem: PhotosPickerItem? = nil
    @State private var selectedImageData: Data? = nil
    @State private var isShowingFileImporter: Bool = false
    @State private var isExportingFile: Bool = false
    @State private var exportDocument: DataDocument? = nil
    @State private var exportedFileName: String = String(localized: "文件")
    @State private var exportUTType: UTType = .data
    
    var body: some View {
        NavigationStack{
            VStack {
               
                
                // 状态指示器
                HStack {
                    Circle()
                        .fill(viewModel.isActive ? Color.green : Color.gray)
                        .frame(width: 10, height: 10)
                    
                    Text(viewModel.isActive ? "已激活" : "未激活")
                        .font(.subheadline)
                        .foregroundColor(viewModel.isActive ? .green : .gray)
                    
                    Spacer()
                    
                    Text("发现 \(viewModel.nearbyPeers.count) 个设备")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
                .padding(.horizontal)
                
                if viewModel.nearbyPeers.count > 0 || viewModel.messages.count > 0{
                    // 消息发送区域
                    VStack {
                        // 消息列表
                        ScrollViewReader { scrollView in
                            ScrollView {
                                
                                VStack(alignment: .leading, spacing: 12) {
                                    ForEach(viewModel.messages, id: \.id) { message in
                                        MessageBubble(
                                            message: message,
                                            isFromCurrentUser: message.isFromCurrentUser,
                                            onSaveImage: { data in
                                                saveImageToPhotos(data)
                                            },
                                            onSaveFile: { data, name in
                                                exportDocument = DataDocument(data: data)
                                                exportedFileName = name ?? String(localized: "文件")
                                                if let name = name {
                                                    let ext = URL(fileURLWithPath: name).pathExtension
                                                    exportUTType = UTType(filenameExtension: ext) ?? .data
                                                } else {
                                                    exportUTType = .data
                                                }
                                                isExportingFile = true
                                            }
                                        )
                                        .id(message.id)
                                    }
                                }
                                .padding()
                                .onChange(of: viewModel.messages.count) { _ in
                                    if let lastMessage = viewModel.messages.last {
                                        withAnimation {
                                            scrollView.scrollTo(lastMessage.id, anchor: .bottom)
                                        }
                                    }
                                }
                            }
                        }
                        
                        // 输入框、选图、发送按钮
                        HStack {
                            TextField("输入消息...", text: $message)
                                .padding(10)
                                .background(Color(.systemGray6))
                                .cornerRadius(8)
                                .onSubmit {
                                    if !message.isEmpty {
                                        viewModel.sendGroupMessage(message)
                                        message = ""
                                    }
                                }

                            PhotosPicker(selection: $selectedPhotoItem, matching: .images, photoLibrary: .shared()) {
                                Image(systemName: "photo")
                                    .font(.system(size: 18))
                                    .foregroundColor(.blue)
                            }
                            .onChange(of: selectedPhotoItem) { newItem in
                                guard let item = newItem else { return }
                                Task {
                                    if let imageTransfer = try? await item.loadTransferable(type: ImageData.self) {
                                        let data = imageTransfer.data
                                        selectedImageData = data
                                        viewModel.sendGroupImage(data)
                                        selectedPhotoItem = nil
                                    }
                                }
                            }

                            Button(action: {
                                isShowingFileImporter = true
                            }) {
                                Image(systemName: "doc")
                                    .font(.system(size: 18))
                                    .foregroundColor(.blue)
                            }
                            .fileImporter(
                                isPresented: $isShowingFileImporter,
                                allowedContentTypes: [.data, .content, .item],
                                allowsMultipleSelection: false
                            ) { result in
                                switch result {
                                case .success(let urls):
                                    if let url = urls.first {
                                        viewModel.sendGroupFile(url: url)
                                    }
                                case .failure(let error):
                                    print("文件选择失败: \(error.localizedDescription)")
                                }
                            }

                            Button(action: {
                                if !message.isEmpty {
                                    viewModel.sendGroupMessage(message)
                                    message = ""
                                }
                            }) {
                                Image(systemName: "paperplane.fill")
                                    .foregroundColor(.blue)
                            }
                            .padding(.horizontal, 10)
                        }
                        .padding()
                        .disabled(viewModel.nearbyPeers.count == 0)
                    }
                }else{
                    VStack(spacing: 20) {
                        Image(systemName: "person.3")
                            .font(.system(size: 50))
                            .foregroundColor(.gray)
                        Text("附近暂无设备")
                            .foregroundColor(.gray)
                        Button(action: {
                            viewModel.refreshNearbyPeers()
                        }) {
                            Text("重新扫描")
                                .foregroundColor(.white)
                                .padding(.horizontal, 20)
                                .padding(.vertical, 10)
                                .background(Color.blue)
                                .cornerRadius(8)
                        }
                    }
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                }
                
            }
            .navigationTitle("附近的书")
            .toolbar{
                ToolbarItem(placement: .topBarTrailing) {
                    Button(action: {
                        showingDevices = true
                    }) {
                        Image(systemName: "antenna.radiowaves.left.and.right")
                            .font(.system(size: 18))
                            .foregroundColor(.blue)
                    }
                }
                ToolbarItem(placement: .navigation) {
                    Button{
                        self.dismiss()
                    }label: {
                        Image(systemName: "xmark")
                    }
                }
            }
            .sheet(isPresented: $showingDevices) {
                DevicesView(viewModel: viewModel)
            }
            .onAppear {
                viewModel.startDiscovery()
            }
            .onDisappear {
                viewModel.stopDiscovery()
            }
            .fileExporter(
                isPresented: $isExportingFile,
                document: exportDocument ?? DataDocument(data: Data()),
                contentType: exportUTType,
                defaultFilename: exportedFileName
            ) { result in
                switch result {
                case .success:
                    print("文件已保存: \(exportedFileName)")
                case .failure(let error):
                    print("文件保存失败: \(error.localizedDescription)")
                }
                exportDocument = nil
            }
        }
    }

    // 保存图片到相册
    private func saveImageToPhotos(_ data: Data) {
        guard let image = UIImage(data: data) else { return }
        PHPhotoLibrary.shared().performChanges({
            PHAssetCreationRequest.creationRequestForAsset(from: image)
        }) { success, error in
            if let error = error {
                print("保存图片失败: \(error.localizedDescription)")
            } else {
                print("图片已保存到相册")
            }
        }
    }
}

// 更安全的图片可传输类型，避免宽泛的类解码
struct ImageData: Transferable {
    let data: Data

    static var transferRepresentation: some TransferRepresentation {
        DataRepresentation(contentType: .image) { imageData in
            imageData.data
        } importing: { data in
            ImageData(data: data)
        }
    }
}

// 消息气泡组件
struct MessageBubble: View {
    let message: NearbyMessage
    let isFromCurrentUser: Bool
    var onSaveImage: ((Data) -> Void)? = nil
    var onSaveFile: ((Data, String?) -> Void)? = nil
    
    var body: some View {
        HStack {
            if isFromCurrentUser { Spacer() }
            VStack(alignment: isFromCurrentUser ? .trailing : .leading, spacing: 6) {
                Group {
                if let data = message.imageData, let uiImage = UIImage(data: data) {
                    Image(uiImage: uiImage)
                        .resizable()
                        .scaledToFit()
                        .frame(maxWidth: 240)
                        .clipShape(RoundedRectangle(cornerRadius: 10))
                        // 进度采用卡片背景颜色覆盖在图片上，从左到右填充
                        .overlay(
                            GeometryReader { geo in
                                let width = max(0, min(geo.size.width * CGFloat(message.progress), geo.size.width))
                                RoundedRectangle(cornerRadius: 10)
                                    .fill((isFromCurrentUser ? Color.blue : .orange).opacity(0.2))
                                    .frame(width: width)
                                    .opacity(message.progress == 1 ? 0 : 1)
                            }, alignment: .leading
                        )
                        .overlay(
                            RoundedRectangle(cornerRadius: 10)
                                .stroke(isFromCurrentUser ? Color.blue : .orange, lineWidth: 1)
                        )
                        .overlay(alignment: .topTrailing) {
                            if message.isTransferring {
                                Text("\(Int(message.progress * 100))%")
                                    .font(.caption2)
                                    .foregroundColor(isFromCurrentUser ? .white : .primary)
                                    .padding(4)
                                    .background((isFromCurrentUser ? Color.blue : .orange).opacity(0.6))
                                    .clipShape(RoundedRectangle(cornerRadius: 6))
                                    .padding(6)
                            }
                        }
                        .contextMenu {
                            Button("保存图片") {
                                onSaveImage?(data)
                            }
                        }
                } else if message.fileName != nil || message.fileData != nil {
                    ZStack(alignment: .leading) {
                        // 进度条背景与填充直接作用于卡片背景
                        RoundedRectangle(cornerRadius: 10)
                            .fill((isFromCurrentUser ? Color.blue : .orange).opacity(0.35))
                        GeometryReader { geo in
                            let width = max(0, min(geo.size.width * CGFloat(message.progress), geo.size.width))
                            RoundedRectangle(cornerRadius: 10)
                                .fill(isFromCurrentUser ? Color.blue : .orange)
                                .frame(width: width)
                                .opacity(message.progress == 1 ? 0 : 1)
                        }
                        HStack(spacing: 8) {
                            Image(systemName: "doc.fill")
                                .foregroundColor(isFromCurrentUser ? .white : .blue)
                            VStack(alignment: .leading, spacing: 4) {
                                Text(message.fileName ?? String(localized: "文件"))
                                    .font(.subheadline)
                                    .foregroundColor(isFromCurrentUser ? .white : .primary)
                                if let data = message.fileData {
                                    Text("大小: \(ByteCountFormatter.string(fromByteCount: Int64(data.count), countStyle: .file))")
                                        .font(.caption)
                                        .foregroundColor(isFromCurrentUser ? .white.opacity(0.9) : .secondary)
                                }
                            }
                            Spacer(minLength: 0)
                        }
                        .padding(10)
                    }
                    .overlay(alignment: .topTrailing) {
                        if message.isTransferring {
                            Text("\(Int(message.progress * 100))%")
                                .font(.caption2)
                                .foregroundColor(isFromCurrentUser ? .white : .primary)
                                .padding(4)
                                .background((isFromCurrentUser ? Color.blue : .orange).opacity(0.6))
                                .clipShape(RoundedRectangle(cornerRadius: 6))
                                .padding(6)
                        }
                    }
                    .contextMenu {
                        if let data = message.fileData {
                            Button("保存文件") {
                                onSaveFile?(data, message.fileName)
                            }
                        }
                    }
                } else {
                    Text(message.content)
                        .padding(10)
                        .background(isFromCurrentUser ? Color.blue : .orange)
                        .foregroundColor(isFromCurrentUser ? .white : .black)
                        .cornerRadius(10)
                }
                }
                // 进度已在卡片内部背景显示，无需额外进度条
            }
            
            if !isFromCurrentUser { Spacer() }
        }
    }
}

// 进度条：采用气泡卡片背景色，从左到右填充 0%~100%
struct BubbleProgressBar: View {
    let progress: Double
    let isFromCurrentUser: Bool

    private var bubbleColor: Color {
        isFromCurrentUser ? Color.blue : Color(.systemGray5)
    }

    private var trackColor: Color {
        bubbleColor.opacity(0.35)
    }

    private var fillColor: Color {
        bubbleColor
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack {
                Text("\(Int(progress * 100))%")
                    .font(.caption2)
                    .foregroundColor(isFromCurrentUser ? .white : .secondary)
                Spacer()
            }
            ZStack(alignment: .leading) {
                RoundedRectangle(cornerRadius: 6)
                    .fill(trackColor)
                    .frame(height: 8)
                GeometryReader { geo in
                    let width = max(0, min(geo.size.width * progress, geo.size.width))
                    RoundedRectangle(cornerRadius: 6)
                        .fill(fillColor)
                        .frame(width: width, height: 8)
                }
            }
            .frame(height: 8)
        }
    }
}

// 通用数据文档用于导出文件
struct DataDocument: FileDocument {
    static var readableContentTypes: [UTType] { [.data] }
    var data: Data

    init(data: Data) { self.data = data }

    init(configuration: ReadConfiguration) throws {
        if let contents = configuration.file.regularFileContents {
            self.data = contents
        } else {
            self.data = Data()
        }
    }

    func fileWrapper(configuration: WriteConfiguration) throws -> FileWrapper {
        return FileWrapper(regularFileWithContents: data)
    }
}

struct NearbyNoLetView_Previews: PreviewProvider {
    static var previews: some View {
        NearbyNoLetView()
    }
}

// 设备列表页面（通过右上角按钮弹出）
struct DevicesView: View {
    @ObservedObject var viewModel: NearbyNoLetViewModel
    @Environment(\.dismiss) var dismiss
    
    var body: some View {
        NavigationStack {
            Group {
                if viewModel.nearbyPeers.isEmpty {
                    VStack(spacing: 20) {
                        Image(systemName: "person.3")
                            .font(.system(size: 50))
                            .foregroundColor(.gray)
                        Text("附近暂无设备")
                            .foregroundColor(.gray)
                        Button(action: {
                            viewModel.refreshNearbyPeers()
                        }) {
                            Text("重新扫描")
                                .foregroundColor(.white)
                                .padding(.horizontal, 20)
                                .padding(.vertical, 10)
                                .background(Color.blue)
                                .cornerRadius(8)
                        }
                    }
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                } else {
                    List {
                        ForEach(viewModel.nearbyPeers) { peer in
                            NearbyNoLetItem(peer: peer)
                                .onTapGesture {
                                    if !peer.isConnected {
                                        viewModel.connectToPeer(peer)
                                    }
                                }
                        }
                    }
                }
            }
            .navigationTitle("附近设备")
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) {
                    Button(action: {
                        viewModel.refreshNearbyPeers()
                    }) {
                        Image(systemName: "arrow.clockwise")
                            .font(.system(size: 18))
                            .foregroundColor(.blue)
                    }
                }
                ToolbarItem(placement: .navigation) {
                    Button{
                        self.dismiss()
                    }label: {
                        Image(systemName: "xmark")
                    }
                }
            }
        }
    }
}
