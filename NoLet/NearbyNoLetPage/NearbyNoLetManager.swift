//
//  NearbyNoLetManager.swift
//  NoLet
//
//  Author:        Copyright (c) 2024 QingHe. All rights reserved.
//  Document:      https://wiki.wzs.app
//  E-mail:        to@wzs.app
//
//
//  Created by AI Assistant on 2023/7/1.
//
// Note: This file contains code automatically generated by AI.
// Usage reminder: Review carefully and thoroughly test before integration or release.

import Combine
import Foundation
import MultipeerConnectivity
import UniformTypeIdentifiers

// 附近设备模型
struct NearbyPeer: Identifiable {
    let id = UUID()
    let peerID: MCPeerID
    var isConnected: Bool = false
}

// 聊天消息模型
struct NearbyMessage: Identifiable {
    let id = UUID()
    let content: String
    let timestamp: Date
    let isFromCurrentUser: Bool
    let senderName: String
    var imageData: Data? = nil
    var fileName: String? = nil
    var fileData: Data? = nil
    // 传输进度（发送或接收中的显示）
    var isTransferring: Bool = false
    var progress: Double = 0.0 // 0.0 ~ 1.0
    var totalPeers: Int = 0
    var completedPeers: Int = 0
}

// 附近设备管理类
class NearbyNoLetManager: NSObject, ObservableObject {
    // 发布者
    @Published var nearbyPeers: [NearbyPeer] = []
    @Published var messages: [NearbyMessage] = []
    @Published var isActive: Bool = false

    // MultipeerConnectivity 组件
    private let serviceType = "nolet"
    private var myPeerID: MCPeerID

    private var session: MCSession
    private var advertiser: MCNearbyServiceAdvertiser
    private var browser: MCNearbyServiceBrowser
    // 进度观测（发送与接收）
    private var sendProgressCancellables: [UUID: [MCPeerID: AnyCancellable]] = [:]
    private var sendProgresses: [UUID: [MCPeerID: Progress]] = [:]
    private var receiveProgressCancellables: [String: AnyCancellable] = [:]
    private var incomingMessageID: [String: UUID] =
        [:] // key: peer.displayName + "|" + resourceName

    // 初始化
    override init() {
        // 创建自己的 PeerID
        myPeerID = MCPeerID(displayName: UIDevice.current.name)

        // 创建会话
        session = MCSession(peer: myPeerID, securityIdentity: nil, encryptionPreference: .required)

        // 创建广播器
        advertiser = MCNearbyServiceAdvertiser(
            peer: myPeerID,
            discoveryInfo: nil,
            serviceType: serviceType
        )

        // 创建浏览器
        browser = MCNearbyServiceBrowser(peer: myPeerID, serviceType: serviceType)

        super.init()

        // 设置代理
        session.delegate = self
        advertiser.delegate = self
        browser.delegate = self
    }

    // 开始发现附近设备
    func startDiscovery() {
        advertiser.startAdvertisingPeer()
        browser.startBrowsingForPeers()
        isActive = true
    }

    // 停止发现
    func stopDiscovery() {
        advertiser.stopAdvertisingPeer()
        browser.stopBrowsingForPeers()
        isActive = false
    }

    // 刷新附近设备
    func refreshNearbyPeers() {
        // 重新开始搜索
        stopDiscovery()
        startDiscovery()
    }

    // 连接到指定设备
    func connectToPeer(_ peer: NearbyPeer) {
        browser.invitePeer(peer.peerID, to: session, withContext: nil, timeout: 30)
    }

    // 发送消息
    func sendMessage(_ message: String, to peer: NearbyPeer) {
        guard let data = message.data(using: .utf8) else { return }

        // 先添加到本地消息列表，确保UI立即更新
        let newMessage = NearbyMessage(
            content: message,
            timestamp: Date(),
            isFromCurrentUser: true,
            senderName: myPeerID.displayName
        )

        DispatchQueue.main.async {
            self.messages.append(newMessage)
        }

        // 然后发送消息
        do {
            try session.send(data, toPeers: [peer.peerID], with: .reliable)
        } catch {
            print("发送消息失败: \(error.localizedDescription)")
        }
    }

    // 群聊：向所有已连接的设备群发消息
    func sendGroupMessage(_ message: String) {
        guard let data = message.data(using: .utf8) else { return }

        // 先添加到本地消息列表，确保UI立即更新
        let newMessage = NearbyMessage(
            content: message,
            timestamp: Date(),
            isFromCurrentUser: true,
            senderName: myPeerID.displayName
        )

        DispatchQueue.main.async {
            self.messages.append(newMessage)
        }

        // 群发到所有已连接的设备
        let peers = session.connectedPeers
        guard !peers.isEmpty else { return }

        do {
            try session.send(data, toPeers: peers, with: .reliable)
        } catch {
            print("群发消息失败: \(error.localizedDescription)")
        }
    }

    // 群聊：发送图片到所有已连接设备
    func sendGroupImage(_ imageData: Data) {
        // 为了显示进度，改用资源发送：写入临时文件并以资源形式群发
        let tempURL = FileManager.default.temporaryDirectory
            .appendingPathComponent("nolet-image-\(UUID().uuidString).jpg")
        do { try imageData.write(to: tempURL) } catch {
            print("写入临时图片失败: \(error.localizedDescription)")
            return
        }

        let peers = session.connectedPeers
        guard !peers.isEmpty else { return }

        let message = NearbyMessage(
            content: "",
            timestamp: Date(),
            isFromCurrentUser: true,
            senderName: myPeerID.displayName,
            imageData: imageData,
            fileName: nil,
            fileData: nil,
            isTransferring: true,
            progress: 0.0,
            totalPeers: peers.count,
            completedPeers: 0
        )

        DispatchQueue.main.async { self.messages.append(message) }
        let msgID = message.id
        sendProgressCancellables[msgID] = [:]
        // 为每个设备启动独立并发任务，确保真正并发
        for peer in peers {
            if let progress = self.session.sendResource(
                at: tempURL,
                withName: "image.jpg",
                toPeer: peer,
                withCompletionHandler: { [weak self] error in
                    guard let self = self else { return }
                    if let error = error {
                        print("图片发送到 \(peer.displayName) 失败: \(error.localizedDescription)")
                    }
                    // 完成计数
                    DispatchQueue.main.async {
                        self.updateMessage(msgID) { m in
                            m.completedPeers += 1
                            m.progress = m
                                .totalPeers > 0 ?
                                (Double(m.completedPeers) / Double(m.totalPeers)) :
                                1.0
                            if m.completedPeers >= m.totalPeers { m.isTransferring = false }
                        }
                        self.sendProgressCancellables[msgID]?[peer] = nil
                    }
                }
            ) {
                let cancellable = progress.publisher(for: \.fractionCompleted)
                    .receive(on: DispatchQueue.main)
                    .sink { [weak self] _ in
                        Task{@MainActor in
                            self?.updateAggregateProgress(messageID: msgID)
                        }
                    }
                DispatchQueue.main.async {
                    self.sendProgressCancellables[msgID]?[peer] = cancellable
                    if self.sendProgresses[msgID] == nil { self.sendProgresses[msgID] = [:] }
                    self.sendProgresses[msgID]?[peer] = progress
                }
            }
        }
    }

    // 群聊：发送文件到所有已连接设备
    func sendGroupFile(_ fileURL: URL) {
        let fileName = fileURL.lastPathComponent
        let scoped = fileURL.startAccessingSecurityScopedResource()
        defer { if scoped { fileURL.stopAccessingSecurityScopedResource() } }
        // 复制到临时目录，避免在发送过程中失去安全域访问
        let tempURL = FileManager.default.temporaryDirectory
            .appendingPathComponent("nolet-file-\(UUID().uuidString)-\(fileName)")
        do {
            if FileManager.default
                .fileExists(atPath: tempURL.path)
            {
                try? FileManager.default.removeItem(at: tempURL)
            }
            try FileManager.default.copyItem(at: fileURL, to: tempURL)
        } catch {
            print("复制文件到临时目录失败: \(error.localizedDescription)")
            return
        }

        let peers = session.connectedPeers
        guard !peers.isEmpty else { return }

        let message = NearbyMessage(
            content: "",
            timestamp: Date(),
            isFromCurrentUser: true,
            senderName: myPeerID.displayName,
            imageData: nil,
            fileName: fileName,
            fileData: nil,
            isTransferring: true,
            progress: 0.0,
            totalPeers: peers.count,
            completedPeers: 0
        )
        DispatchQueue.main.async { self.messages.append(message) }
        let msgID = message.id
        sendProgressCancellables[msgID] = [:]
        // 为每个设备启动独立并发任务，确保真正并发
        for peer in peers {
            if let progress = self.session.sendResource(
                at: tempURL,
                withName: fileName,
                toPeer: peer,
                withCompletionHandler: { [weak self] error in
                    guard let self = self else { return }
                    if let error = error {
                        print("群发文件失败到 \(peer.displayName): \(error.localizedDescription)")
                    }
                    self.updateMessage(msgID) { m in
                        m.completedPeers += 1
                        m.progress = m
                            .totalPeers > 0 ?
                            (Double(m.completedPeers) / Double(m.totalPeers)) :
                            1.0
                        if m.completedPeers >= m.totalPeers { m.isTransferring = false }
                    }
                    DispatchQueue.main.async {
                        self.sendProgressCancellables[msgID]?[peer] = nil
                    }
                }
            ) {
                let cancellable = progress.publisher(for: \.fractionCompleted)
                    .receive(on: DispatchQueue.main)
                    .sink { [weak self] _ in
                        self?.updateAggregateProgress(messageID: msgID)
                    }
                DispatchQueue.main.async {
                    self.sendProgressCancellables[msgID]?[peer] = cancellable
                    if self.sendProgresses[msgID] == nil { self.sendProgresses[msgID] = [:] }
                    self.sendProgresses[msgID]?[peer] = progress
                }
            }
        }
    }

    // 更新连接状态
    private func updatePeerConnectionState(_ peerID: MCPeerID, isConnected: Bool) {
        DispatchQueue.main.async {
            if let index = self.nearbyPeers.firstIndex(where: { $0.peerID == peerID }) {
                var updatedPeer = self.nearbyPeers[index]
                updatedPeer.isConnected = isConnected
                self.nearbyPeers[index] = updatedPeer
            }
        }
    }
}

// MARK: - MCSessionDelegate

extension NearbyNoLetManager: MCSessionDelegate {
    func session(_: MCSession, peer peerID: MCPeerID, didChange state: MCSessionState) {
        switch state {
        case .connected:
            print("已连接到: \(peerID.displayName)")
            updatePeerConnectionState(peerID, isConnected: true)
        case .connecting:
            print("正在连接到: \(peerID.displayName)")
        case .notConnected:
            print("未连接到: \(peerID.displayName)")
            updatePeerConnectionState(peerID, isConnected: false)
        @unknown default:
            break
        }
    }

    func session(_: MCSession, didReceive data: Data, fromPeer peerID: MCPeerID) {
        // 尝试按文本解码，否则作为图片处理
        if let messageText = String(data: data, encoding: .utf8) {
            let newMessage = NearbyMessage(
                content: messageText,
                timestamp: Date(),
                isFromCurrentUser: false,
                senderName: peerID.displayName,
                imageData: nil,
                fileName: nil,
                fileData: nil
            )
            DispatchQueue.main.async { self.messages.append(newMessage) }
        } else {
            let newMessage = NearbyMessage(
                content: "",
                timestamp: Date(),
                isFromCurrentUser: false,
                senderName: peerID.displayName,
                imageData: data,
                fileName: nil,
                fileData: nil
            )
            DispatchQueue.main.async { self.messages.append(newMessage) }
        }
    }

    // 以下方法为必须实现的协议方法，但本功能暂不使用
    func session(
        _: MCSession,
        didReceive _: InputStream,
        withName _: String,
        fromPeer _: MCPeerID
    ) {}

    func session(
        _: MCSession,
        didStartReceivingResourceWithName resourceName: String,
        fromPeer peerID: MCPeerID,
        with progress: Progress
    ) {
        // 创建占位消息以显示接收进度
        let placeholder = NearbyMessage(
            content: "",
            timestamp: Date(),
            isFromCurrentUser: false,
            senderName: peerID.displayName,
            imageData: nil,
            fileName: resourceName,
            fileData: nil,
            isTransferring: true,
            progress: 0.0,
            totalPeers: 1,
            completedPeers: 0
        )
        DispatchQueue.main.async { self.messages.append(placeholder) }
        let msgID = placeholder.id
        let key = peerID.displayName + "|" + resourceName
        incomingMessageID[key] = msgID

        let cancellable = progress.publisher(for: \.fractionCompleted)
            .receive(on: DispatchQueue.main)
            .sink { [weak self] frac in
                self?.updateMessage(msgID) { m in
                    m.progress = frac
                }
            }
        receiveProgressCancellables[key] = cancellable
    }

    func session(
        _: MCSession,
        didFinishReceivingResourceWithName resourceName: String,
        fromPeer peerID: MCPeerID,
        at localURL: URL?,
        withError error: Error?
    ) {
        guard error == nil else {
            print("接收文件失败: \(error!.localizedDescription)")
            return
        }

        guard let localURL = localURL else { return }
        let data = try? Data(contentsOf: localURL)
        let key = peerID.displayName + "|" + resourceName
        if let msgID = incomingMessageID[key] {
            // 根据扩展识别类型，图片则填充到 imageData
            let ext = URL(fileURLWithPath: resourceName).pathExtension.lowercased()
            let isImage: Bool = {
                if let type = UTType(filenameExtension: ext) { return type.conforms(to: .image) }
                return ["jpg", "jpeg", "png", "gif", "heic", "bmp", "tiff"].contains(ext)
            }()
            updateMessage(msgID) { m in
                if isImage {
                    m.imageData = data
                } else {
                    m.fileData = data
                }
                m.isTransferring = false
                m.progress = 1.0
            }
        } else {
            let newMessage = NearbyMessage(
                content: "",
                timestamp: Date(),
                isFromCurrentUser: false,
                senderName: peerID.displayName,
                imageData: nil,
                fileName: resourceName,
                fileData: data
            )
            DispatchQueue.main.async { self.messages.append(newMessage) }
        }
        receiveProgressCancellables[key] = nil
    }

    // 更新指定消息（线程安全地在主线程）
    private func updateMessage(_ id: UUID, _ mutate: @escaping (inout NearbyMessage) -> Void) {
        DispatchQueue.main.async {
            if let idx = self.messages.firstIndex(where: { $0.id == id }) {
                var msg = self.messages[idx]
                mutate(&msg)
                self.messages[idx] = msg
            }
        }
    }

    // 聚合所有 peer 的进度为消息的平均值
    private func updateAggregateProgress(messageID: UUID) {
        let perPeerProgress = sendProgresses[messageID] ?? [:]
        guard let msg = messages.first(where: { $0.id == messageID }) else { return }
        let total = max(msg.totalPeers, 1)
        let fractionalSum = perPeerProgress.values.reduce(0.0) { $0 + $1.fractionCompleted }
        let newProgress = min(max(fractionalSum / Double(total), 0.0), 1.0)
        updateMessage(messageID) { m in m.progress = newProgress }
    }

    // 对外：清理临时缓存（发送时写入的临时图片与文件）
    func clearCaches() {
        let tempDir = FileManager.default.temporaryDirectory
        let fm = FileManager.default
        if let urls = try? fm.contentsOfDirectory(
            at: tempDir,
            includingPropertiesForKeys: nil,
            options: [.skipsHiddenFiles]
        ) {
            for url in urls {
                let name = url.lastPathComponent
                if name.hasPrefix("nolet-image-") || name.hasPrefix("nolet-file-") {
                    try? fm.removeItem(at: url)
                }
            }
        }
    }
}

// MARK: - MCNearbyServiceAdvertiserDelegate

extension NearbyNoLetManager: MCNearbyServiceAdvertiserDelegate {
    func advertiser(
        _: MCNearbyServiceAdvertiser,
        didReceiveInvitationFromPeer _: MCPeerID,
        withContext _: Data?,
        invitationHandler: @escaping (Bool, MCSession?) -> Void
    ) {
        // 自动接受连接邀请
        invitationHandler(true, session)
    }

    func advertiser(_: MCNearbyServiceAdvertiser, didNotStartAdvertisingPeer error: Error) {
        print("广播失败: \(error.localizedDescription)")
    }
}

// MARK: - MCNearbyServiceBrowserDelegate

extension NearbyNoLetManager: MCNearbyServiceBrowserDelegate {
    func browser(
        _ browser: MCNearbyServiceBrowser,
        foundPeer peerID: MCPeerID,
        withDiscoveryInfo _: [String: String]?
    ) {
        // 发现新设备
        let newPeer = NearbyPeer(
            peerID: peerID,
            isConnected: session.connectedPeers.contains(peerID)
        )

        DispatchQueue.main.async {
            // 检查是否已存在
            if !self.nearbyPeers.contains(where: { $0.peerID == newPeer.peerID }) {
                self.nearbyPeers.append(newPeer)
            }
        }

        // 自动邀请对方加入会话，实现自动加入群聊
        browser.invitePeer(peerID, to: session, withContext: nil, timeout: 10)
    }

    func browser(_: MCNearbyServiceBrowser, lostPeer peerID: MCPeerID) {
        // 设备离线，从列表中移除
        DispatchQueue.main.async {
            self.nearbyPeers.removeAll(where: { $0.peerID == peerID })
        }
    }

    func browser(_: MCNearbyServiceBrowser, didNotStartBrowsingForPeers error: Error) {
        print("浏览失败: \(error.localizedDescription)")
    }
}

// 进度观测
