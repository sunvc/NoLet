//
//  LocalNetwork.swift
//  NoLet
//
//  Created by Neo on 2025/11/2.
//
// Note: This file contains code automatically generated by AI.
// Usage reminder: Review carefully and thoroughly test before integration or release.

import MultipeerConnectivity
import Network

class PeerSessionManager: NSObject {
    static let shared = PeerSessionManager()
    
    private let serviceType = NCONFIG.appSymbol.lowercased()
    private var peerID: MCPeerID!
    private var session: MCSession!
    private var advertiser: MCNearbyServiceAdvertiser!
    private var browser: MCNearbyServiceBrowser!
    
    // 消息接收回调
    var onMessageReceived: ((String, MCPeerID) -> Void)?
    var onPeerStatusChanged: ((MCPeerID, MCSessionState) -> Void)?
    
    // 初始化
    private override init() {
        super.init()
        setupPeerSession()
    }
    
    deinit{
        advertiser.stopAdvertisingPeer()
        browser.stopBrowsingForPeers()
    }
    
    private func setupPeerSession() {
        peerID = MCPeerID(displayName: UIDevice.current.name)
        session = MCSession(peer: peerID, securityIdentity: nil, encryptionPreference: .required)
        session.delegate = self
        
        // 广播自身
        advertiser = MCNearbyServiceAdvertiser(peer: peerID, discoveryInfo: nil, serviceType: serviceType)
        advertiser.delegate = self
        advertiser.startAdvertisingPeer()
        
        // 搜索附近设备
        browser = MCNearbyServiceBrowser(peer: peerID, serviceType: serviceType)
        browser.delegate = self
        browser.startBrowsingForPeers()
    }
    
    // 获取当前连接的所有设备
    var connectedPeers: [MCPeerID] {
        return session.connectedPeers
    }
    
    // 发送数据（例如发送字符串）- 群发消息
    func sendMessage(_ message: String) {
        guard let data = message.data(using: .utf8), !session.connectedPeers.isEmpty else { return }
        do {
            try session.send(data, toPeers: session.connectedPeers, with: .reliable)
        } catch {
            print("发送失败: \(error)")
        }
    }
    
    // 发送消息到特定设备
    func sendMessage(_ message: String, toPeer peer: MCPeerID) {
        guard let data = message.data(using: .utf8) else { return }
        do {
            try session.send(data, toPeers: [peer], with: .reliable)
        } catch {
            print("发送失败: \(error)")
        }
    }
}

// MARK: - MCSessionDelegate 处理会话状态和数据接收
extension PeerSessionManager: MCSessionDelegate {
    func session(_ session: MCSession, peer peerID: MCPeerID, didChange state: MCSessionState) {
        print("设备 \(peerID.displayName) 状态变更为: \(state)")
        
        // 通知状态变更
        DispatchQueue.main.async {
            self.onPeerStatusChanged?(peerID, state)
        }
        
        switch state {
        case .connected:
            print("已连接: \(peerID.displayName)")
            // 连接成功后发送欢迎消息
            self.sendMessage("已加入群聊", toPeer: peerID)
        case .connecting:
            print("连接中...")
        case .notConnected:
            print("断开连接: \(peerID.displayName)")
        @unknown default:
            break
        }
    }
    
    func session(_ session: MCSession, didReceive data: Data, fromPeer peerID: MCPeerID) {
        if let message = String(data: data, encoding: .utf8) {
            print("收到来自 \(peerID.displayName) 的消息: \(message)")
            // 在主线程更新 UI
            DispatchQueue.main.async {
                // 通过回调传递消息
                self.onMessageReceived?(message, peerID)
            }
        }
    }
    
    // 以下方法按需实现（文件/流传输）
    func session(_ session: MCSession, didReceive stream: InputStream, withName streamName: String, fromPeer peerID: MCPeerID) {}
    func session(_ session: MCSession, didStartReceivingResourceWithName resourceName: String, fromPeer peerID: MCPeerID, with progress: Progress) {}
    func session(_ session: MCSession, didFinishReceivingResourceWithName resourceName: String, fromPeer peerID: MCPeerID, at localURL: URL?, withError error: Error?) {}
}

// MARK: - Advertiser & Browser Delegates
extension PeerSessionManager: MCNearbyServiceAdvertiserDelegate, MCNearbyServiceBrowserDelegate {
    // 收到连接请求
    func advertiser(_ advertiser: MCNearbyServiceAdvertiser, didReceiveInvitationFromPeer peerID: MCPeerID, withContext context: Data?, invitationHandler: @escaping (Bool, MCSession?) -> Void) {
        invitationHandler(true, session) // 自动接受邀请
    }
    
    // 发现附近设备
    func browser(_ browser: MCNearbyServiceBrowser, foundPeer peerID: MCPeerID, withDiscoveryInfo info: [String : String]?) {
        browser.invitePeer(peerID, to: session, withContext: nil, timeout: 10) // 自动邀请对方
    }
    
    func browser(_ browser: MCNearbyServiceBrowser, lostPeer peerID: MCPeerID) {
        print("设备离线: \(peerID.displayName) \(peerID.description)")
        
    }
}

